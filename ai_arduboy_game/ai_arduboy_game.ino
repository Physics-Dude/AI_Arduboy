/*
  This is an Arduboy game titled: AI ARDUBOY (v1.0)

  The idea is that you have to teach an AI what 'modules' are constructive or destructive.
  There are over half-a-million possible modules. You have to hurry though, if it loads a
  module before you train it, you loose points. If you guess improperly, the AI will
  start to show signs of corruption! ooooOO! Features cool bleep bloop sounds too!
  (The typing sound is directly akin to the W.O.P.R.'s text stream in the opening of
  the 1983 film War Games!)

  Inspired in part by  ZackFreedman's Singularitron/SingularitronFirmware/flavortext.h
  Over a thousand aditional vocabulary words were added from inspirition gained from
  various websites I visit, and Discord servers I frequent. Thanks to those that chimed in!

  Here is a Google Sheet/Excel document that you can use to make your own verb/noun lists:
  https://docs.google.com/spreadsheets/d/1g_faTWEzZ0kmPCXj78JnV4_LHmt-BcecV4cVemXffTM/
*/

#include <Arduboy2.h>
Arduboy2 arduboy;
BeepPin1 beep;

//fonts by filmote
//https://community.arduboy.com/t/3x5-font-for-those-with-good-eyesight/4920
#include "src/fonts/Font3x5.h"
Font3x5 font3x5 = Font3x5();
#include "src/fonts/Font4x6.h"
Font4x6 font4x6 = Font4x6();

// Massive comma-seperated text arraysstored in flash. Generated by Google doc above.
const char constructiveVerbs[] PROGMEM = "Align,Build,Calibrat,Instanc,Configur,Strumm,Microwav,Tweak,Wrangl,Hack,Pwn,Boot,Allocat,Bind,Revv,Polish,Fabricat,Ping,Refactor,Load,Quantify,Assembl,Distill,Bak,Receiv,Unlock,Compil,Pressuriz,Chooch,Mak,Engag,Decrypt,Synthesiz,Predict,Analyz,Dispens,Fir,Insert,Encourag,Extrud,Access,Sharpen,Enhanc,Crank,Stack,Craft,Render,Mount,Generat,Implement,Download,Construct,Wow! Amaz,Moisten,Customiz,Compensat,Buffer,Transferr,Induct,Emitt,Unzipp,Squirt,Feed,Buy,Spark,Implant,Triangulat,Inject,Link,Brew,Process,Deploy,Tun,Attach,Train,Ignor,Tapp,Reload,Simulat,Fluff,Fill,Sort,Updat,Upgrad,Prim,Trac,Inflat,Charg,Sign,Activat,Dial,Pimp,Collect,Approach,Sampl,Energiz,Roleplay,Lubricat,Personaliz,Fus,Apply,Reserv,Power,Gett,Wir,Mind,Accelerat,Correct,Play,Enforc,Acquir,Observ,Initiat,Initializ,Contact,Increas,Install,Send,Concatenat,Weld,Start,Fluoresc,Fortify,Clarify,Multiply,Electrify,Beautify,Simplify,Glorify,Unify,Strengthen,Illuminat,Harmoniz,Moderniz,Consolidat,Demystify,Industrializ,Contribut,Achiev,Assist,Complet,Consider,Defend,Develop,Discover,Enjoy,Guess,Improv,Involv,Manag,Pick-n-plac,WiFi Enabl,Teach,Learn,Paint,Spell check,Hugg,Tast,Smell,Lick,Lov,Furify,Brows,Call,Signal,3D print,Manufactur,Plott,Record,Shopp,Nam,Resurrect,Join,Combin,Referenc,Plant,Read,Defragment,Lift,Circulat,Launch,Network,Level,Propagat,Tim,Pars,Optimis,Factor,Plac,Post process,Check,Gain,Prob,Validat,Virtualiz,Emulat,Formulat,Connect,K,Fix,Master,Includ,Measur,Draw,Print,Debounc,Documentat,Logg,Film,Cann,Tweet,Mend,Spawn,Enchant,Extrapolat,Acknowledg,Kiss,Milk,Tessellat,Breed,Fold,Winn,Replenish,Floss,Schedul,Try,Pend,Tend,Hold,OwO,UwU,Fulfill,Cach,Embedd,Automat,Machine learn,Mesh network,Subscrib,Forward,Equipp,Monitor,Form,Model,Shar,Enabl,Imag,Facilitat,Evolv,Calculat,Comput,Stimulat,Establish,Encounter,Humor,Test,Walk,Runn,Speed Walk,Color,Saturat,Upscal,Supersampl,Anti-alias,Sync,Pipelin,Illustrat,Graph,Multithread,Speedrunn,Turbo,Ioniz,Fact check,Hydrat,Water,Seed,Disinfect,Beam,Dos,Conduct,Superconduct,Focus,Chill,Inspir,Invent,Wear,Indicat,Pay,Straighten,Order,Deliver,Grow,Rational,Study,Engineer,Pentest,Aid,Lead,Bridg,Defin,Supercharg,Turbocharg,Decorat,Sens,Materializ,Classify,Tighten,Rat,Recondition,Live stream,Ray trac,Cel shad,Rectify,Committ,Merg,Pull,Amplify,Digitiz,Examin,Remote controll,Controll,Greet,Guid,Upload,Scann,Pitch,Button,Kitt,Pack,Batch,Ascend,Liv,Liven,Oscillat,Season,Styliz,Storyboard,Supply,Levitat,Translat,Hoist,Future-proof,Land,Excell,Vulcaniz,Rubb,Fram,Feature creep,Elect,Sav,Repair,Hoot,Enrich,Key,Intak,Meter,Fertiliz,Bejewel,Authoriz,Commission,Pattern match,Caption,Wireless charg,Danc,Debugg,Unlimit,Reconcil,Googl,Biohack,Torrent,Produc,Seduc,Post,Demux,Phase-lock,Ramp,Spoon,Magnetiz,Fetch,Moo,Synergiz,Screen,Boost,Ring,Pag,Summariz,Tag-team,Mass-produc,Spoon-feed,Waterproof,Proofread,Dry clean,Hand-pick,Road-test,Self driv,Self-install,Hand craft,Park,Crav,Servic,Licens,Register,Publish,Remember,Forg,Knitt,Knight,Photograph,Dust,Empower,Color cod,Dry,Internaliz,Freshen,Preen,Explor,Wander,Winteriz,LARP,Farm,Affirm,Clon,Better,Furr,Work,Watch,Anneal,Operat,Utiliz,Experiment,Refurbish,Maximiz,Innovat,Revamp,Lather,Felt,Pretreat,Seal,Separat,Smooth,Stabiliz,Wrapp,Tow,Unclogg,Dress,Extract,Fasten,Reattach,Restor,Adjust,Annotat,Arrang,Coat,Cool,Design,Freez,Glu,Hir,Juggl,Label,Lac,Laminat,Mapp,Past,Plugg,Point,Pour,Queue,Rais,Round,Solder,Ty,Typ,Uncoil,Unfold,Flux,Optimiz,Programm,Decod,Decompress,Transmitt,Index,Search,Aggregat,Visualiz,Interpret,Associat,Reverseengineer,Import,Verify,Bootstrapp,Subsidiz,Approv,Refresh,Cit,Pump,Stuff,Qualify,Fetishify,Rac,Excit,Consum,Secur,Plann,Boop,Mat,Tap,Wangjangl,Feel,Press,Capp,Cheez,sudo,Be,Meet,Flavor,";
const char destructiveVerbs[] PROGMEM = "Trash,Unplugg,Revok,Forgett,Discard,Dropp,Holster,Shredd,Jettison,Dissolv,Liquidat,Releas,Collimat,Eject,Ditch,Leak,Sell,Bann,Dereferenc,Sacrific,Desolder,Decompil,Blow,Disengag,Digest,Smash,Encrypt,Crash,Lock,Purg,Regrett,Rewind,Free,Delet,Clos,Retract,Collaps,Liquefy,Derezz,Stow,Archiv,Suspend,Suppress,Clean,Squash,Withdraw,Dump,Obfuscat,Break,Scrubb,Abandon,Flatten,Stash,Finish,Evacuat,Scrambl,Recycl,Crush,Zipp,Unload,Disconnect,Loosen,Contain,Debat,Detach,Neutraliz,Hid,Disarm,Pickl,Disregard,Yeet,Scrapp,Deflat,Discharg,Deactivat,Steriliz,Reliev,Nuk,Degauss,Drain,Reject,Nerf,Bit shift,Return,Unstick,Cancell,Sham,Embezzl,Fling,Halt,Arrest,Bury,Yiff,Report,Distort,Liquify,Splash,Reprogramm,Rewir,Reform,Burn,Question,Battl,Inhal,Vor,Steal,Delaminat,Eras,Terminat,Annihilat,Obliterat,Wip,Discontinu,Uninstall,Unlink,Disassembl,Expir,Void,Dismantl,Deplet,Demolish,Pulveriz,Shatter,Clear,Extinguish,Eradicat,Stabb,Eliminat,Desert,Remov,Displac,Demoniz,Intensify,Pollut,Dehumaniz,Mystify,Stigmatiz,Normaliz,Stretch,Snapp,Stitch,Snitch,Oxidiz,Melt,Fry,Heat,Irradiat,Abort,Electrifry,Capitaliz,Brandish,Kick,Slapp,Wiggl,Throw,Raid,Screw,Nail,Ripp,Saw,Mill,Laser cutt,Undock,Integrat,Sauc,Metabolis,Fragment,Resett,Flush,Dop,Cannibaliz,Corrupt,Slic,Overlapp,Filter,Mask,Sandbagg,Ruptur,Mirror,Reflect,Claim,Limit,Shav,Min,Drill,Suck,Pilfer,Spoil,Loot,Gossip,Eat,Intersect,Delay,Stall,Vap,Edit,Impregnat,Carbonat,Fumbl,Data min,Snip,Gam,Despawn,Hard fault,Slay,Bit,Wrongdo,Sext,Jinx,Boil,Affect,Knott,Randomiz,Catalyz,Beat,Crack,Undo,Sandblast,Disrespect,Deport,Graft,Re-rout,Offer,Chang,Distribut,Restructur,Flood,Flow,Reflow,Clocc,Fad,Cod,Divid,Us,Reus,Cluster,Touch,XOR,Invert,Bias,Ag,Captur,Hunt,Blam,Thermal throttl,Alias,Wax,Sniff,Miss,Shrink,Compress,Vandaliz,Squelch,Hammer,Rain,Hiss,Wait,Defy,Photoshopp,Desync,Fapp,Dehydrat,Sputter,Semiconduct,Etch,Alarm,Profil,Deez,Warm,Fangirl,Deny,Fox,Ramshackl,Snort,Dispers,Deband,Interpolat,Polariz,Vibrat,Troll,Carboniz,Sublimat,Leav,Follow,Argu,Shotgunn,Rapid fir,Cramm,Bump,Pick,Bully,Prank,Handicapp,Wast,Truncat,Track,Sleep,Dimm,Opening and clos,Branch,Speculat,Padd,Offsett,Block,Formatt,Overwrit,Mix,Skimm,Penaliz,Prun,Popp,Criticiz,Disturb,Moon,Overthink,Misus,Calcify,Ream,Strain,Salivat,Repeat,Deform,Sneez,Escap,Deepthroat,Fart,Gagg,Mut,Reboot,Relaunch,Heck,Swordfight,Unsee,Unlearn,Global warm,Militariz,Exhaust,Los,Haunt,Trapp,Box,Turn,Crumpl,Hang,Derp,Nomm,Chew,Lagg,Buzz,Overload,Transfer,Doubt,Hash,rm -rf /,Delint,Mismatch,Slamm,Peck,Nibbl,Light,Signal convert,Mux,Phas,Crowbarr,Challeng,Unsett,Binn,Demagnetiz,Chunk,Autoremov,React,Wring,Freeze-dry,Downgrad,Sidetrack,Spoof,Red-flagg,Brainwash,Self destruct,Hard wir,Heart-break,Face-plant,Hair rais,Pierc,Garnish,Glutton,Rag,Staff,Hemm,Regurgitat,Rippl,Modify,Gasify,Resist,Misspell,Wett,Vector,Recall,Pass,Skipp,Direct,Negat,Whipp,Decimat,Slim,Flash,Dampen,Shock,Vent,Vex,Crisp,End,Fenc,Froth,Flirt,Stopp,Manipulat,Alter,Transform,Dic,Glaz,Clearcoat,Squanch,U-turn,Bust,Partition,Tear,Exchang,Tea bagg,Bond,Clapp,Breach,Trimm,Vacuum,Unscrew,Grind,Jiggl,Snipp,Spread,Spray,Sweep,Bend,Blend,Brand,Cement,Clipp,Cover,Cutt,Digg,Dipp,Knock,Mow,Pry,Punch,Push,Roll,Rak,Sapp,Scrap,Shap,Squeez,Stamp,Stick,Stripp,Smear,Twist,Unroll,Varnish,Compost,Encod,Export,Migrat,Recover,Fear,Machin,Wizz,Cull,Exploit,Overflow,Underflow,Recurs,Deallocat,Destroy,Writ,Underpinn,Rocket,Shuffl,Exterminat,Degass,Laz,Nullify,Fourier transform,DDoS,Plushify,Empty,Splitt,Dismiss,Unsubscrib,Pinn,Hemorrhag,Null,Franchis,Salvag,Dripp,Jamm,Deindustrializ,De-coloniz,Quantum tunnel,Deriv,Pok,Fezz,Short,Fizz,Sting,Gatekeep,";
const char nouns[] PROGMEM = "your mom,the shmoo,API,the BJT man,aesthetics,backstory,tactics,bugs,warp drive,data,AI,crystals,spaghetti,fluxgate,electrons,loud noises,wires,bytecode,the truth,magic,hot lava,bits,Teensy,sensors,photons,signal,the planet,password,chips,circuits,privacy,synergy,widgets,love,packets,reality,lasers,protocols,voltage,puns,dogecoins,kittens,magic smoke,plot device,the core,dank memes,subroutines,radiation,steam,trousers,beer,protocol,one-liners,the Gibson,software,a fat one,holograms,magnets,inductors,resistors,capacitors,viewers,subscribers,sausage,drama,the future,vectors,the clowns,a Palm Pilot,5G implant,monkeys,breadboard,Patreon,money,the Internet,fluids,the impostor,beats,dopamine,fedora,neural net,comments,ports,you. Yes you,mixtape,[REDACTED],hot tub,paperwork,Nerf,cyber-doobie,the 1%,the Matrix,variables,IP address,cowboys,Steam IDs,protogens,dragons,weebs,furries,e621,browser history,Bad Dragons,con badge,art,yiff,ooze,framerate,souls,the camera,the kraken,text,physics,user-space,chemical bonds,the cake,CDs,intruders,everyone,antivirus,divine spirits,Gordon Freeman,Kleiner,Father Grigori,headcrabs,zombies,nanites,players,client info,LUA,fine art,the 1800s,the 2000s,Python3,JavaScript,HTML,Arduinos,Arduboy,RaspberryPi,Linux,Windows NT,MS-DOS 6.22,x86,microcode,shift registers,7400 series logic,packages,YouTube,Reddit,servers,myself oh noo!,valentines,my mate,Europe,America,time,spacetime,string theory,the present,the past,music,unit tests,your car,silicon,cookies,PLA,ABS,PETG,3D printers,thermal detonator,intelligence,coffee,tea,Florida,Canada,SD cards,storage,heaters,merch,plushies,fish-n-chips,ham borger,ads,debris,stickers,IRC,mana,new lines,spacecraft,anime waifus,ESP8266,ATMEGA32U4,PID loops,podcasts,RSS feeds,coconuts,chemtrails,dependencies,netlists,registers,EEPROM,everyone else,TCP packets,Timings,connectivity,memory contents,FIFO buffer,Clocks,Macros,Checksum,Program Files,System32,Constants,PROGMEM,watchdog timers,FPGAs,bit masks,bitstreams,onboard clocks,timers,Sandboxs,my pet rock,batteries,Wikipedia,Comic Sans,the inevitable,fear,encabulator,synthesizers,the voices,diamond pickaxe,segmentation faults,Minecraft,voxels,my soul,crypto,my buttons,my mind,linguine,pests,the man on TV,karma,therapy,door-to-door,static cling,to see what happens,taxes,appointments,glassware,probes,insulators,film theory,hurdles,big data,RFID chips,CAN bus,IoT,IT,role models,cache,edge cases,world domination,game cart,subscriptions,snoot,algorithms,rabbit holes,tantalums,MissingNo.,Motorola 6809,video RAM,buffer,frame buffer,Reality Synthesizer,entropy,ions,something good,something you like,something,the speed of sound,thermodynamics,copycats,modules,hardware,firewire,firmware,the 90s,the ecosystem,vitals,clock cycles,the mainframe,xkcd,#FFA500,demon core,facts,super magnets,thin films,third base,databases,fanfics,vulnerabilities,graphics,cryptography,operating system,crumbs,public static void,stdlib.h,Cheez Whiz,options,opinions,tears,depression,emotions,memories,brains,signal generator,holy water,solder blobs,555 timer,a blog,hot glue,converter,decoys,electric eels,productivity,coefficients,tar,valves,sectors,links,headers,flags,references,abstraction,ethics,community,QR codes,malware,homepage,dpkg,RNG,civilization,null island,atoms,the mobius,viruses,webcomics,dirt,water,chemicals,uranium-232,dust,code,electrodes,zero-day exploits,bad jokes,out of bounds,my clone,nanobots,blockchain,black hole,Unicode,SSL,Y2K,Dogecoin,Developers,torrents,DNS,Proxy,ISO 8601,Windows ME,Windows Vista,192.168.1.1,Your Mum,0xDEADBEEF,source,ambiguous patterns,SMDs,iron,xscreensaver,precious metals,raw ore,man-db,package lists,state information,grid,controller,electronics,comics,VR,architecture,the 70s,the apocalypse,totem poles,Murphys Law,mixtapes,power,boids,colour TV,CMD,Terminal,averages,Failures,Enemies,a good one,feathers,fur,fuses,clout,RGB,Bluetooth,WiFi,Watchdog,bots,silly business,business,Firefox,Chrome,Waterfox,Internet Explorer,IE6,explorer.exe,/var/www,loose ends,relationships,hotspot,datacenters,the funk,robo calls,spam,systems,accessories,peripherals,HID devices,GUI,input devices,media controls,libraries,the thing,firecrackers,fire,I guess,I think,peets,meat,MOSFETs,botnets,graphene,binary code,ransomware,virtual reality,spyware,3D benchy,robotics,trojan,neural networks,worms,cloud computing,data analytics,virus,cybersecurity,hackers,encryption,firewall,the cloud,battery,renewables,energy,climate change,carbon footprint,biodiversity,habitats,ecosystems,space travel,time travel,AI singularity,cyborgs,genetics,evolution,elements,galaxies,black holes,chemistry,biology,nature,public key,daemon,scintillator,the gremlo,content,the Eastern Seaboard,Furry_IRL,intermediate files,sauce,free space,body parts,Discord,Brad,my wife,race conditions,TF2,Mossman,Gaben,Sub-Nyquist Sampling,supply and demand,embedded controllers,quantum computing,my fursona,franchises,sex,nixie tubes,hats,fish,GitHub,ping,apt,";
//Stats: Total Words:1546, Constructive:515, Destructive:515, Nouns:516, Total pairings:531480

//blank lines (for testing program space)
//const char constructiveVerbs[] PROGMEM = "";
//const char destructiveVerbs[] PROGMEM = "";
//const char nouns[] PROGMEM = "";

unsigned int sizeConstructiveVerbs;
unsigned int sizeDestructiveVerbs;
unsigned int sizeNouns;

unsigned int numConstructiveVerbs;
unsigned int numDestructiveVerbs;
unsigned int numNouns;

// Used for finding and storing new phrases (aka AI modules)
String newThought = "";
unsigned int wordIndex = 0;
unsigned int wordCount = 0;
bool iWillBeConstructive = 0;

// Used to determine if user pressed button early while printing
bool quickDOWN = false;
bool quickUP = false;

// Difficulty which defines charactor size and speeds
byte difficulty = 1; //1,2,3
byte maxLineLength = 0;
byte maxRows = 0;
byte lineHeight = 0;
byte letterWidth = 0;
byte lastLine = 0;

// Array to store phrase history.
const byte NUM_STRINGS = 10;
String logArray[NUM_STRINGS] = {};

// Keep score and 'strikes'
const byte maxStrikes = 3;
byte strike = 0;
int score = 0;

// Statesaving
byte autoLoad = 0;
bool gameStart = false;
bool soundON = true;
bool invertTextState = false;

//                                                                          //Effects and Helpers
//Reset all game vars and clear screen
void resetEnv() {
  strike = 0;
  score = 0;
  gameStart = false;
  autoLoad = 0;
  invertTextState = false;
  arduboy.clear();

  // Erase the entire logArray
  for (int i = 0; i < maxRows; i++) {
    logArray[i] = "";
  }
}

// Invert arduboy text color
void invertText() {
  invertTextState = !invertTextState;
  if (invertTextState) {
    arduboy.setTextColor(BLACK);
    arduboy.setTextBackground(WHITE);
  }
  else {
    arduboy.setTextColor(WHITE);
    arduboy.setTextBackground(BLACK);
  }
}

// Flash the screen when hurt
void flashy(byte durs) {
  for (byte i = 0; i < 3; i++) {
    if (soundON) beep.tone(2222);
    arduboy.allPixelsOn(1);
    delay(durs);
    beep.noTone();
    arduboy.allPixelsOn(0);
    delay(durs);
  }
}

//Animate a little loading icon
String loadSym = "/-\\|";
byte symState = 0;
void loadingIcon(byte locx, byte locy) {
  arduboy.setCursor(locx, locy);
  arduboy.print(loadSym.charAt(symState));
  if (symState <= 2)symState++;
  else symState = 0;
  arduboy.display();
}

//                                                                          Mode Selecting
//Set game difficulty and print some text for the menu
void changeDifficulty(signed char updown) {
  difficulty += updown;
  if (difficulty < 1) difficulty = 1;
  else if (difficulty > 3) difficulty = 3;

  if (soundON && updown) {
    beep.tone(1111 * (4 - difficulty)); //3333, 1666, 1111
    delay(80);
    beep.noTone();
  }

  //Remove old text
  arduboy.setCursor(0, 56);
  for (int i = 0; i < 11; i++) {
    arduboy.print(' ');
  }

  //Print new text and update globals
  switch (difficulty) {
    case 1: //arduboy default font
      maxLineLength = 21;
      maxRows = 6;
      lineHeight = 9;
      letterWidth = 6;
      lastLine = 56;
      arduboy.setCursor(0, lastLine);
      arduboy.print(F("Mode:Normal"));
      break;
    case 2: //font4x6
      maxLineLength = 25;
      maxRows = 7;
      lineHeight = 8;
      letterWidth = 5;
      lastLine = 56;
      font4x6.setCursor(0, lastLine);
      font4x6.print(F("Mode:Rush"));
      break;
    case 3://font3x5
      maxLineLength = 31;
      maxRows = 9;
      lineHeight = 6;
      letterWidth = 4;
      lastLine = 57;
      font3x5.setCursor(0, lastLine);
      font3x5.print(F("Mode:Panic"));
      break;
  }
  arduboy.display();
}

// Toggle sound on/off and display a pretty icon
void toggleSoundFun(bool doChange = true) {
  if (doChange) soundON = !soundON;

  // Print sound icon in the top right
  arduboy.setCursor(123, 0);
  if (soundON) arduboy.print((char)14);
  else arduboy.print(' ');
  arduboy.display();

  // Boop
  if (doChange) {
    int soundA = 1400;
    beep.tone(soundA);
    delay(80);
    if (!soundON) soundA = 3900;
    beep.tone(soundA);
    delay(80);
    beep.noTone();
  }
}

// Cycle and/or print subtext/lore.
uint8_t subTitleCycle = 0;
void drawSubText(uint8_t cycle = 0) { //cycle 0 = just display, 1 = increment, 2 = decrement
  // Cool little optimization that removes a constant and a couple if's
  subTitleCycle = (subTitleCycle + cycle) % 3;

  // Blank out the old subtext
  arduboy.fillRect(0, 17, 128, 29, BLACK);
  arduboy.setCursor(0, 20);

  // Choose and display text
  switch (subTitleCycle) {
    case 0:
      arduboy.println(F("Teach this AI what is"));
      arduboy.setCursorY(29);
      arduboy.print(F("GOOD("));
      arduboy.print((char)24); //up arrow
      arduboy.print(F(") and BAD("));
      arduboy.print((char)25); // down arrow
      arduboy.println(F(")."));
      arduboy.setCursorY(38);
      arduboy.print(F("Hurry! He's loading."));
      break;

    case 1:
      arduboy.println(F("Constructive modules"));
      arduboy.setCursorY(29);
      arduboy.print(F("are "));
      arduboy.fillRect(23, 28, 31, 9, WHITE);
      invertText(); arduboy.print(F("GOOD!")); invertText();
      arduboy.println(F(" Destructive"));
      arduboy.setCursorY(38);
      arduboy.print(F("modules are "));
      arduboy.fillRect(71, 37, 25, 9, WHITE);
      invertText(); arduboy.print(F("BAD!")); invertText();
      break;

    case 2:
      arduboy.setCursorX(1);
      arduboy.fillRect(0, 19, 19, 9, WHITE);
      invertText(); arduboy.print(F("Tip")); invertText();
      arduboy.println(F(" Wrong data causes"));
      arduboy.setCursorY(29);
      arduboy.println(F("corruption! Timeouts" ));
      arduboy.setCursorY(38);
      arduboy.print(F("lose you a point!"));
      break;
  }

  //arduboy.setCursorX(123);
  //arduboy.print((char)18); // updown arrow
  arduboy.display();
}

//                                                                            Printing Press
//Print one char to the bottom line of the display in the correct font
void printer(uint8_t character, int pos) {
  //Animate typing with cursor
  arduboy.fillRect(pos, 62, letterWidth - 1, 2, WHITE);
  arduboy.display();
  if (pos == 0) delay(random(900 / difficulty));

  // Make a beep boop that sounds like the W.O.P.R. from War Games (1983)
  int boopTime = 27 / difficulty;
  if (soundON) beep.tone(1080);
  delay(boopTime);
  if (soundON) beep.tone(869);
  delay(boopTime);
  beep.noTone();

  arduboy.fillRect(pos, 62, letterWidth - 1, 2, BLACK);
  arduboy.display();

  //Print the right char
  switch (difficulty) {
    case 1: //arduboy default font
      arduboy.setCursor(pos, lastLine);
      arduboy.print((char)character);
      break;
    case 2: //font4x6
      font4x6.setCursor(pos, lastLine);
      font4x6.print((char)character);
      break;
    case 3://font3x5
      font3x5.setCursor(pos, lastLine);
      font3x5.print((char)character);
      break;
  }
}

//Take a string and send it to the printer one char at a time. Check buttons while at it.
void printerWrapper (String input) {
  quickDOWN = false;
  quickUP = false;

  for (int i = 0; i < input.length(); i++) {
    arduboy.pollButtons();
    printer(input.charAt(i), letterWidth * i);
    if (arduboy.justPressed(UP_BUTTON) && !quickDOWN) quickUP = true;
    if (arduboy.justPressed(DOWN_BUTTON) && !quickUP) quickDOWN = true;
    if (arduboy.justPressed(B_BUTTON)) toggleSoundFun();
  }

  /*
    // Occasionally print a letter starting from the first instance of a space (too spicy?)
    byte startPos;
    byte i = 0;
    if (random(10) > 1) startPos = 0;
    else startPos = input.indexOf(' ');
    while (i <= input.length()) {
      if (startPos > input.length()) {
        startPos = 0;
      }
      arduboy.pollButtons();
      printer(input.charAt(startPos), letterWidth * startPos);
      if (arduboy.justPressed(UP_BUTTON) && !quickDOWN) quickUP = true;
      if (arduboy.justPressed(DOWN_BUTTON) && !quickUP) quickDOWN = true;
      if (arduboy.justPressed(B_BUTTON)) toggleSoundFun();
      i++;
      startPos++;
    }
  */


}

//                                                                              Setup
void setup() {
  arduboy.begin();
  beep.begin();
  arduboy.setFrameRate(20);

  //Get the size of the arrays (char counts)
  sizeConstructiveVerbs = sizeof(constructiveVerbs);
  sizeDestructiveVerbs = sizeof(destructiveVerbs);
  sizeNouns = sizeof(nouns);

  //Get the number of words in each array (word counts)
  for (int i = 0; i < sizeConstructiveVerbs; i++) {
    char c = pgm_read_byte(constructiveVerbs + i);
    if (c == ',') numConstructiveVerbs++;
  }
  for (int i = 0; i < sizeDestructiveVerbs; i++) {
    char c = pgm_read_byte(destructiveVerbs + i);
    if (c == ',') numDestructiveVerbs++;
  }
  for (int i = 0; i < sizeNouns; i++) {
    char c = pgm_read_byte(nouns + i);
    if (c == ',') numNouns++;
  }

  resetEnv();
}

//                                                                            Loop Start
void loop() {
  // Pause render until it's time for the next frame
  if (!(arduboy.nextFrame()))
    return;

  //                                                                           Main Menu
  //if game hasent started, show the menu
  if (!gameStart) {

    //Print title
    arduboy.setCursor(0, 0);
    arduboy.setTextSize(2);
    arduboy.print(F("AI"));
    arduboy.setCursorX(33);
    arduboy.print(F("ARDUBOY"));
    //arduboy.print(F("TRAINER"));
    arduboy.drawFastHLine(0, 16, 128);
    arduboy.setTextSize(1);

    drawSubText(0);

    font4x6.setCursor(94, 56);
    font4x6.print(F("Press A"));

    //Update main menu (they will call arduboy.display())
    changeDifficulty(0);
    toggleSoundFun(false);//dont change state

    //Bootup sound

    //Wait for A press
    while (!arduboy.pressed(A_BUTTON)) {
      if (arduboy.nextFrame()) {
        arduboy.pollButtons();
        if (arduboy.justPressed(B_BUTTON)) toggleSoundFun();
        else if (arduboy.justPressed(LEFT_BUTTON)) changeDifficulty(-1);
        else if (arduboy.justPressed(RIGHT_BUTTON)) changeDifficulty(1);
        else if (arduboy.justPressed(UP_BUTTON)) {
          drawSubText(2);
        }
        else if (arduboy.justPressed(DOWN_BUTTON)) {
          drawSubText(1);
        }

        //HDD noise and autoloader
        if (millis() > 1000 && random(10) < difficulty) {
          if (soundON) beep.tone(300);
          delay(3);
          beep.noTone(); // Stop the tone if one is playing

          autoLoad++;
          if (autoLoad == 50 || autoLoad == 100) drawSubText(1);
          arduboy.drawFastHLine(0, 50, autoLoad);
          arduboy.drawFastHLine(0, 51, autoLoad);
          if (autoLoad >= 127) break;
        }
        loadingIcon(123, 8);
      }
    }

    //Lets begin sound
    if (soundON) {
      beep.tone(288);
      delay(111);
      beep.tone(343);
      delay(333);
      beep.noTone();
    }

    gameStart = true;
    arduboy.clear();
  }

  //                                                                            Game State
  if (gameStart) {

    //Generate a phrase that fits
    bool itFits = false;

    while (!itFits) {
      // Initilize new string
      newThought = "";
      // Desired word index
      wordIndex = 0;
      // Count of the words
      wordCount = 0;

      // Choose if printing constructive or destructive
      iWillBeConstructive = random(2);

      // Search for a constructive or destructive verb in the PROGMEM lists
      if (iWillBeConstructive) {
        wordIndex = random(numConstructiveVerbs);
        // Iterate through the PROGMEM string, one character at a time
        for (int i = 0; i < sizeConstructiveVerbs; i++) {
          char c = pgm_read_byte(constructiveVerbs + i);

          // If the current character is a comma, increment the word count
          if (c == ',') wordCount++;

          // If we have reached the nth word, write out the chars.
          else if (wordCount == wordIndex) newThought += c;

          // If we have reached the end of the word, close it and break from the for loop.
          if (wordCount > wordIndex) break;
        }
      }
      else {
        wordIndex = random(numDestructiveVerbs);
        // Iterate through the PROGMEM string, one character at a time
        for (int i = 0; i < sizeDestructiveVerbs; i++) {
          char c = pgm_read_byte(destructiveVerbs + i);

          // If the current character is a comma, increment the word count
          if (c == ',') wordCount++;

          // If we have reached the nth word, write out the chars.
          else if (wordCount == wordIndex) newThought += c;

          // If we have reached the end of the word, close it and break from the for loop.
          if (wordCount > wordIndex) break;
        }
      }

      // Got a verb, add an "ing"
      newThought += "ing";

      // Not doing so well? reverse a verb for funny
      if (random(32) < strike) {
        String backWord = "";
        for (int i = newThought.length() - 1; i >= 0; i--) {
          backWord += newThought[i];
        }
        newThought = backWord;
      }

      // Space
      newThought += " ";

      // Search for a noun in the PROGMEM list
      wordCount = 0;
      wordIndex = random(numNouns);
      // Iterate through the string, one character at a time
      for (int i = 0; i < sizeNouns; i++) {
        char c = pgm_read_byte(nouns + i);

        // If the current character is a comma, increment the word count
        if (c == ',') wordCount++;

        // If we have reached the nth word, print out the chars.
        else if (wordCount == wordIndex) newThought += c;

        // If we have reached the end of the word, close it and break from the for loop.
        if (wordCount > wordIndex) break;
      }

      // Get length of a complete String. If its longer than needed, go back to top and find a new one.
      if (newThought.length() < maxLineLength) itFits = true;
    }

    // Got a full phrase. Add an "..."
    newThought += "... ";

    // Send string to printer.
    printerWrapper(newThought);

    // Shift the log array down by one element
    for (int i = maxRows - 1; i > 0; i--) {
      logArray[i] = logArray[i - 1];
    }
    // Add the new string to the top of the array
    logArray[0] = newThought;

    // Mark the time of the newThought and generate a time for the player to respond
    unsigned long startThinkingTime = millis();
    int thinkingTime = random(1200, 9000) / difficulty;
    thinkingTime -= (score * 10);
    if (thinkingTime < 0 || thinkingTime > 9000) {
      thinkingTime = 0;
    }

    // If this changes, we know the user made a choice
    byte choice = 255;

    // Give the user some time to answer.
    do  {
      arduboy.pollButtons();
      if (arduboy.justPressed(B_BUTTON)) toggleSoundFun();

      if (arduboy.justPressed(UP_BUTTON) || quickUP) {
        if (soundON) beep.tone(1000);
        if (!iWillBeConstructive) flashy(40);
        beep.noTone();
        choice = 1;
        break;
      }
      if (arduboy.justPressed(DOWN_BUTTON) || quickDOWN) {
        if (soundON) beep.tone(1000);
        if (iWillBeConstructive) flashy(40);
        beep.noTone();
        choice = 0;
        break;
      }
      if (arduboy.nextFrame()) {
        loadingIcon(123, 0);
      }

      //Running out of time
    } while (millis() < startThinkingTime + thinkingTime);

    // Test if player made correct choice
    if (iWillBeConstructive == choice) {
      if (soundON) beep.tone(2222);
      delay(100);
      if (soundON) beep.tone(1176);
      delay(100);

      // Correct! do a happy up-beat if constructive, or a happy down beat if destructive
      int uppidyTone = 454;
      if (!iWillBeConstructive)  uppidyTone = 500;
      if (soundON) beep.tone(uppidyTone);
      delay(120);
      beep.noTone();
      score++;
    }

    // Test if player made wrong choice
    else if (iWillBeConstructive != choice && choice <= 1) {
      //Corrupt some data
      for (int i = 0; i < 10; i++) {
        int lineToCorrupt = random(maxRows);
        int letterToCorrupt = random(maxLineLength);
        int charToReplace = random(255);
        while (charToReplace >= 32 && charToReplace <= 128) {
          charToReplace = random(32);
        }
        logArray[lineToCorrupt].setCharAt(letterToCorrupt, charToReplace);
      }
      strike++;
    }

    // Player ran out of time.
    else {
      //outta time, minus point
      if (soundON) beep.tone(4545);
      delay(90);
      if (soundON) beep.tone(1515);
      delay(90);
      if (soundON) beep.tone(3030);
      delay(111);
      beep.noTone();
      score--;
    }

    // Print the log to the screen.
    arduboy.clear();
    int posFirstLog = lastLine - lineHeight;
    for (int i = 0; i < maxRows; i++) {
      switch (difficulty) {
        case 1: //arduboy default font
          arduboy.setCursor(0, posFirstLog);
          arduboy.println(logArray[i]);
          break;
        case 2: //font4x6
          font4x6.setCursor(0, posFirstLog);
          font4x6.println(logArray[i]);
          break;
        case 3://font3x5
          font3x5.setCursor(0, posFirstLog);
          font3x5.println(logArray[i]);
          break;
      }
      posFirstLog -= lineHeight;
    }
    arduboy.display();

    // GAME OVER show game over screen
    if (strike >= maxStrikes) {
      bool blonk = false;
      bool failOnce = false;
      const byte ox = 17;
      const byte oy = 19;
      arduboy.frameCount = 0;

      // Wait for player to press A (>Abort)
      unsigned long failTime = millis();
      while (!arduboy.pressed(A_BUTTON)) {

        if (arduboy.nextFrame()) {
          arduboy.pollButtons();
          if (arduboy.justPressed(B_BUTTON)) toggleSoundFun();

          // Blink every n frames
          if (arduboy.everyXFrames(12)) {
            blonk = !blonk;
            //if (soundON && !blonk) beep.tone(300);
            //delay(2);
            beep.noTone();
          }

          arduboy.fillRect(0 + ox, 0 + oy, 93, 21);
          invertText();

          arduboy.setCursor(2 + ox, 2 + oy);
          if (!blonk) arduboy.println(F("**LOAD FAILED**"));
          else {
            for (int i = 0; i < 15; i++) {
              arduboy.print(' ');
            }
            arduboy.println();
          }

          arduboy.setCursor(2 + ox, 12 + oy);
          arduboy.print(F("ERR ON LINE:"));
          arduboy.setCursor(73 + ox, 12 + oy);
          arduboy.print(score);
          invertText();

          arduboy.setCursor(2 , 56);
          arduboy.fillRect(0, 55, 128, 10, WHITE);
          invertText();
          arduboy.print(F(">Abort, Retry, Fail?"));
          invertText();

          arduboy.display();

          // Play the game over sound once
          if (!failOnce) {
            for (int i = 1; i < 11 && soundON ; i++) {
              //beep.tone(random(1000, 4000));
              beep.tone((i * 400));
              delay(80);
            }
            //beep.tone(4000);
            //beep.noTone();
            failOnce = true;
          }
        }

        // Leave the game over screen if left idle for too long (screen saver)
        if (millis() > failTime + 60000) break;
      }

      // Cool wipe effect
      for (int i = 127; i > 0; i--) {
        arduboy.drawFastVLine(i, 0, 128, BLACK);
        arduboy.display();
        delay(4);
      }

      //We are done. Reset the game environment so we can return to menu.
      resetEnv();
    }
  }
}
